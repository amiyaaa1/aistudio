# dark-proxy-vps

本项目提供一个针对 Google Gemini/OpenAI 兼容接口的反向代理，并支持为每个账号自动分发调用密钥，便于多人共用同一套部署。

## 部署与运行
1. **安装依赖**：
   ```bash
   npm install
   ```
2. **启动服务**：
   ```bash
   npm start
   ```
   服务器默认监听 `0.0.0.0:7860`，通过环境变量 `PORT` 可修改端口。
3. **反代客户端**：
   将 `dark-browser-vps.js` 的内容粘贴到 Zeabur（或其它前端托管）生成的页面 Build 脚本中，按以下方式配置：
   - 将文件顶部的 `ACCOUNT_EMAIL` 改为该浏览器实例所登录的 Google 账号邮箱；也可在访问页面时追加 `?account=<email>` 覆盖。
   - 一个账号对应一个浏览器登录态，分别打开多个页面即可同时保持多账号连接。
   - 浏览器脚本会在连接 WebSocket 时把账号邮箱带到后端，用于请求路由。

## 账号密钥机制
- 后端会在首次收到形如 `/<account-email>`（例如 `/xxxxx@gmail.com`）的请求时，为该邮箱生成一个 24 位调用密钥。
- 密钥字符从 `A-Z`、`a-z`、`0-9`、`-` 这 53 个字符随机选择，可重复。
- 访问 `https://<你的公网域名>/<account-email>` 即可获取密钥，返回示例：
  ```json
  { "account": "demo@gmail.com", "key": "Abc...xyz" }
  ```
- 每个账号只有一个密钥；重复访问会返回同一密钥，便于用户自行保存。

## 使用密钥调用代理
- **查询参数**：在请求中追加 `?key=<你的密钥>`。
- **Authorization 头**：也可使用 `Authorization: Bearer <你的密钥>`。
- 旧版单一密钥仍可通过环境变量 `MY_SECRET_KEY` 配置，默认值为 `123456`；任一有效账号密钥或 `MY_SECRET_KEY` 都能通过鉴权。
- 后端会根据密钥反查邮箱并路由到同邮箱的浏览器连接；若该账号未连接会返回 503，不会落到其他账号上。
- 支持 OpenAI 兼容接口：
  - 列表模型：`GET /v1/models`。
  - Chat Completions：`POST /v1/chat/completions`（支持 `stream`）。
- 其它路径会直接透传给后端，`key` 仅用于鉴权，不会转发。

## 常见问题
- **连接状态检查**：访问根路径 `/`，若显示 `✅ 代理就绪` 表示已有浏览器客户端连接。
- **切换模式**：
  - `GET /admin/set-mode?mode=fake|real` 用于切换伪造/真实流模式。
  - `GET /admin/get-mode` 查看当前模式。

## 额度与账号隔离说明
- 每个账号邮箱对应唯一密钥；后端在收到请求后会根据密钥反查账号，并**只会把请求转发到同账号的浏览器连接**。
- 如果对应账号的浏览器连接不存在或掉线，将返回 503，不会落到其他账号的浏览器上，从而避免额度串用。
- 只有使用 `MY_SECRET_KEY` 时，后端才会回退到“首个在线浏览器连接”，因此需要隔离额度时请给用户发放各自的账号密钥。

### 常见疑问：A 额度耗尽后会影响 B 吗？
- **不会串用额度。** 现在每个账号有独立的浏览器连接，A 的密钥只会匹配并使用登录了账号 A 的浏览器，无法落到账号 B 的连接上。
- **举例**：
  1. 浏览器 1 登录账号 **A**，并以 `ACCOUNT_EMAIL=A` 连接后端；浏览器 2 登录账号 **B**，以 `ACCOUNT_EMAIL=B` 连接后端。
  2. 账号 **A** 的密钥持有者调用接口（`?key=<A 的密钥>`）。
  3. 后端根据密钥找到账号 A，并只将请求转发到浏览器 1；不会消耗账号 B 的额度。
  4. 若浏览器 1 离线，A 的请求会得到 503，提示账号未连接，而不会落到账号 B 上。
- **建议**：确保每个浏览器实例都登录对应账号，并使用各自密钥；仅在不关心隔离时才使用 `MY_SECRET_KEY` 共享首个连接。

如需自定义，请参考 `dark-server-vps.js` 与 `dark-browser-vps.js` 的实现。
